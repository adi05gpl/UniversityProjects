# -*- coding: utf-8 -*-
"""MIB2021_lab07_08.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cj-0EGiYnwEA-K_7y3p_khrnKUr5PxwZ

# Laborator 07-08

Familia algoritmilor evolutivi este vastă, există multe versiuni cu diferite proprietăți și caracteristici. Însă, aceste metode împărtășesc aceleași principii de operare și componente comune:
- Schema de reprezentare a soluțiilor (genotip, fenotip, etc.)
- Operatori de încrucișare, bazate pe principiul [eredității](https://ro.wikipedia.org/wiki/Ereditate) (ex. crossover)
- Operatori de [mutație](https://ro.wikipedia.org/wiki/Muta%C8%9Bie_genetic%C4%83), perturbare a soluțiilor (ex. bit-flipping)
- O funcție de evaluare pentru [fitness](https://en.wikipedia.org/wiki/Fitness_function)
- O strategia de selecție (ex. selecția tip ruletă, selecția tunir etc.)
- Strategia de evoluție (ex. rata de mutație, încrucișare etc.)

## Distributed Evolutionary Algorithms in Python (DEAP)

[DEAP](https://github.com/DEAP/deap) este o librărie python ce facilitează implementarea algoritmilor evolutivi. Ea oferă o modalitate simplificată și organizată pentru definirea diferitelor componente mai sus amintite.

DEAP oferă numeroase componente predefinite (variațiile cele mai des folosite, descrise în literatura de specialitatee), totodată oferind și o suficientă flexibilitate, opțiuni pentru definirea propriilor variații, modificări a acestoor componente (pentru probleme pentru care componentele predefinite nu sunt suficiente).

## Instalarea pe mașina  viruală Colab

Folosim comanda `pip install`:
"""

!pip install deap

"""## Importarea componentelor principale"""

from deap import algorithms
from deap import base
from deap import creator
from deap import tools

"""# Exemplu de utlizare

Vom utiliza o metodă ES pentru a găsi coeficienții unei funcții polinomiale (presuspus necunoscută -  pentru un input, putem observa doar o valoare evaluată perturbată de zgomot).


"""

import numpy as np
import random

def groundTruth(x):
  return 1.42*x + 2.84*x**2 - 0.2*x**3 + 4.2

# ieșirea este perturbată de zgomot
def sample(inputs):
    return np.array([groundTruth(inp) + np.random.normal(0.5) for inp in inputs])

# efectul zgomotului aditiv - input constant, rezultate diferite
for i in range(0, 10):
  print(sample([1]))

"""Pentru a modela, optimiza un proces folosind un algoritm evolutiv, trebuie să definim ce tip de model căutăm. Pentru exemplul actual, vom presupune că știm că modelul pe care îl căutăm este un polinom de cel mult gradul 4 (în exemplul concret este de gradul 3, astfel algoritmul evolutiv va trebui să determine coeficienții peentru termenii $x^k$ unde $k>3$  ca fiind egali cu 0 )."""

# o solutie va fi reprezentata de 5 numere reale ([a1, a2, a3, a4, c]): a1*x + a2*x^2 + a3*x^3 + a4*x^4 + c
IND_SIZE = 4

"""Într-un prim pas, definim reprezenatrea soluțiilor, strategia de selecție și funcția fitness."""

import array
# dorim să minimizăm funcția
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))

# reprezenatre - un șir (array) de numere reale (double)
creator.create("Individual", array.array, typecode="d", fitness=creator.FitnessMin, strategy=None)
creator.create("Strategy", array.array, typecode="d")

"""În pasul următor, de obicei definim funcțiile ce facilitează utilizarea reprezentării alese pentru a genera indivizi (în algpritmul evolutiv) și a forma o populație. Pentru acest scop DEAP oferă un "utilitar", denumit `toolbox`."""

def generateES(individual, strategy, size):
    ind = individual(np.random.normal() for _ in range(size))
    ind.strategy = strategy(np.random.normal() for _ in range(size))
    return ind

toolbox = base.Toolbox()

# functii pt. generarea indivizilor si a populatiei
toolbox.register("individual", generateES, creator.Individual, creator.Strategy, IND_SIZE)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

"""Funcția fitness va măsura eroarea, determinată empiric, pentru o soluție propusă (individ)."""

data = [(0,0)]
for i in np.linspace(-5, 5, 100):
  data.append( (i, i) )
print(data)

def evaluatePolynomial(ind, x):
    y = 0.0
    for i in range(1,IND_SIZE):
        y += ind[i-1]*x**i
    y += ind[IND_SIZE-1]

    return y

def fitness(ind, data):
    # mean square error
    mse = 0.0
    for x, y in data:
      val = evaluatePolynomial(ind, x)
      err  = y - val
      mse += err**2

    return mse/len(data),

toolbox.register("evaluate", fitness, data=data)

"""Parametrizăm algoritmul, spețificând operatorii predefiniți pe care dorim să îi foolosim: https://deap.readthedocs.io/en/master/api/algo.html"""

# parametrii pt. alg algorithms.eaMuCommaLambda
toolbox.register("mate", tools.cxESBlend, alpha=0.1)
toolbox.register("mutate", tools.mutESLogNormal, c=1.0, indpb=0.3)
toolbox.register("select", tools.selTournament, tournsize=4)

"""Cu ajutorul modului `Statistics` putem genera statisticile (și afișsa) aferente prodesului de optimizare."""

stats = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("avg", np.mean)
stats.register("std", np.std)
stats.register("min", np.min)
stats.register("max", np.max)

# reținem cele mai bune 10 soluții
hof = tools.HallOfFame(10)

pop = toolbox.population(n=100)

pop, logbook = algorithms.eaMuCommaLambda(pop, toolbox, mu=100, lambda_=200,
            cxpb=0.6, mutpb=0.2, ngen=1000, stats=stats, halloffame=hof, verbose=True)

"""Afișsarea celor mai bune soluții:"""

for h in hof:
  print('Solution [a1={}, a2={}, a3={}, a4={}, c={}]  has fitness {}'.format(h[0], h[1], h[2], h[3], h[4], h.fitness))

"""# Exerciții

1. Comparați grafic soluțiile cele mai bune cu soluția optimă (funcția `groundTruth`) pe intervalul $[-5, 5]$.
2. Cum este afectat convergența metodei, calitatea soluțiilor, dacă:
  - Probabilitatea de mutație (`mutpb`) este (mult) redusă;
  - Amplitudinea zgomotului aditiv este (mult) mai mare;
  - Modelul utilizat este mai exact, gradul polinomului căutat este maximum 3 (`IND_SIZE = 4`).
3. Importați [acest](https://github.com/DEAP/notebooks/blob/master/OneMax.ipynb) notebook și studiați exemplul de optimizare prezentat, pentru problema [OneMax](https://tracer.lcc.uma.es/problems/onemax/onemax.html).
4. Implementați cu ajutorul DEAP un algoritm evolutiv, ce găsește șiruri binare în care diferența absolută dintre numârul biților setate 1 și numârul biților setate 0 este minimă  (0 pntru șiruri de lungime pară, 1 pentru lungimi impare).
  ```
  f(bstring) = abs(sum(bstring==1) - sum(bstring==0))
  ```

1)
"""

#Mycode
data = [(0,0)]
for i in np.linspace(-5, 5, 100):
  data.append( (i, i) )
print(data)

# parametrii pt. alg algorithms.eaMuCommaLambda
toolbox.register("mate", tools.cxESBlend, alpha=0.1)
toolbox.register("mutate", tools.mutESLogNormal, c=1.0, indpb=0.3)
toolbox.register("select", tools.selTournament, tournsize=4)

stats = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("avg", np.mean)
stats.register("std", np.std)
stats.register("min", np.min)
stats.register("max", np.max)

# reținem cele mai bune 10 soluții
hof = tools.HallOfFame(10)

pop = toolbox.population(n=100)

pop, logbook = algorithms.eaMuCommaLambda(pop, toolbox, mu=100, lambda_=200,
            cxpb=0.6, mutpb=0.2, ngen=200, stats=stats, halloffame=hof, verbose=True)

import matplotlib.pyplot as plt

plt.plot(hof.items)

"""2)"""

pop = toolbox.population(n=100)

pop, logbook = algorithms.eaMuCommaLambda(pop, toolbox, mu=100, lambda_=200,
            cxpb=0.6, mutpb=0.02, ngen=1000, stats=stats, halloffame=hof, verbose=True)

for h in hof:
  print('Solution [a1={}, a2={}, a3={}, c={}]  has fitness {}'.format(h[0], h[1], h[2], h[3], h.fitness))

plt.plot(hof.items)

"""REZULTAT : FUNCTIA CONVERGE MAI RAPID SI AJUNGE LA O PRECIZIE MAI BUNA MAI RAPID.

onex to 1 and 0 quals or 1 difference
"""

import random
from deap import base, creator, tools, algorithms

creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMax)

ind = creator.Individual([1, 0, 1, 1, 0])

print(ind)
print(type(ind))
print(type(ind.fitness))

toolbox = base.Toolbox()
toolbox.register("attr_bool", random.randint, 0, 1)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_bool, n=10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

bit = toolbox.attr_bool()
ind = toolbox.individual()
pop = toolbox.population(n=3)

print("bit is of type %s and has value\n%s" % (type(bit), bit))
print("ind is of type %s and contains %d bits\n%s" % (type(ind), len(ind), ind))
print("pop is of type %s and contains %d individuals\n%s" % (type(pop), len(pop), pop))

def evalOneMax(individual):
    return sum(individual),

def evalAverageDifference(stringVal):
   sumZeros=0
   sumOnes=0
   for str in stringVal:
     if str == 0 :
      sumZeros += 1
     else :
      sumOnes+=1
   return (10-(abs(sumZeros-sumOnes))),

toolbox.register("evaluate", evalAverageDifference)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutFlipBit, indpb=0.10)
toolbox.register("select", tools.selTournament, tournsize=3)

ind = toolbox.individual()
print(ind)
toolbox.mutate(ind)
print(ind)

mutant = toolbox.clone(ind)
print(mutant is ind)
print(mutant == ind)

def main():
    import numpy

    pop = toolbox.population(n=5000)
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", numpy.mean)
    stats.register("min", numpy.min)
    stats.register("max", numpy.max)

    pop, logbook = algorithms.eaSimple(pop, toolbox, cxpb=0.5, mutpb=0.2, ngen=10, stats=stats, halloffame=hof, verbose=True)

    return pop, logbook, hof

if __name__ == "__main__":
    pop, log, hof = main()
    print("Best individual is: %s\nwith fitness: %s" % (hof[0], hof[0].fitness))

    import matplotlib.pyplot as plt
    gen, avg, min_, max_ = log.select("gen", "avg", "min", "max")
    plt.plot(gen, avg, label="average")
    plt.plot(gen, min_, label="minimum")
    plt.plot(gen, max_, label="maximum")
    plt.xlabel("Generation")
    plt.ylabel("Fitness")
    plt.legend(loc="lower right")
    plt.show()