# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C-5knECbmR3OS5MEcfv8ozHqxHrBjqwm

**Image processing with Matlab **
# 1. Color spaces:
The ***rgb2lab*** function converts an image from RGB to Lab.

Code example:
*    sbRGB = imread("strawberryPlant.jpg");

*                 imshow(sbRGB)



Task: Convert sbRGB to Lab and save the result in sbLab.
"""

sbLab = rgb2lab(sbRGB);
imshow(sbLab)

"""A representation in the Lab color space has three channels:

*   Luminance is stored in the first plane and contains brightness from black to white.
*   The a* channel is stored in the second plane and contains a measurement of hue from green to red.
*   The b* channel is stored in the third plane and contains a measurement of hue from blue to yellow.

Task: Extract the luminance plane and save it to the variable L. Display the distribution of pixel intensities using the histogram function.
"""

L = sbLab(:,:,1);
histogram(L)

"""To display the luminance plane, you need to scale the values to between 0 and 1. You can do this directly in the imshow command using square brackets.

*   imshow(im,[])


Task: Display the luminance plane, setting the display range to zero to one.
"""

imshow(L,[])

"""Task: Extract the a* plane and save it to the variable a. Display the result with the display range set to zero to one."""

a = sbLab(:,:,2);
imshow(a,[])

"""Task: Extract the b* plane and save it to the variable b. Display the result with the display range set to zero to one."""

b = sbLab(:,:,3);
imshow(b,[])

"""The a* plane does the best job of separating the red strawberries from the green background. You can view the intensity histogram to determine a threshold.

Task:Display the histogram of intensity values for the a* plane using the histogram function.
  


"""

histogram(a)

"""You can see two clusters of intensities in the a* channel. The higher values correspond to the strawberries, which have more red than green in them.

Task: Create a binary mask that is true everywhere a is greater than 21. Save the result in redSBmask, and display the result.

"""

redSBmask = a > 21;
imshow(redSBmask)

"""The luminance channel looks a lot like a grayscale image, but they aren't the same. Try viewing the grayscale image and luminance channel side-by-side."""

gs = im2gray(sbRGB);
imshowpair(L,gs,"montage")

"""The grayscale image is a weighted average of the red, green, and blue planes. See the algorithms section of the documentation for ***im2gray*** for details.

2. Control Points

In this practice, you will map an image of a brain with Alzheimer's (the moving image) onto an image of a normal brain (the fixed image). Control points identifying locations in the brain with Alzheimer's with locations in the normal brain have been loaded into the workspace as the variables alzheimerPts and normalPts.

Before calculating the geometric transformation from the control points, you can fine-tune the control points using cross-correlation. Cross-correlation helps ensure that the control points were placed most accurately.

* movPtsCor = cpcorr(movPts,fixPts,movIm,fixIm);
  
The cpcorr function adjusts the control points by up to four pixels, so the adjustment may be subtle.
"""

# Commented out IPython magic to ensure Python compatibility.
alzheimer = imread("alzheimerBrain.png");
normal = imread("normalBrain.png");
imshowpair(alzheimer,normal,"montage")

load brainControlPoints.mat

# % cpselect(alzheimer,normal)
alzheimerPts
normalPts

"""TASK

Adjust the control points for the moving image using cross-correlation, and save the result back to the original variable.
"""

alzheimerPts = cpcorr(alzheimerPts,normalPts,alzheimer,normal)

"""You can create a geometric transformation using control points with the fitgeotrans function.

* tForm = fitgeotrans(movingPts,fixedPts,type)

TASK

Create an "affine" transformation using the Alzheimer's brain as the moving image and the normal brain as the fixed image, and save the result to tForm.
"""

tForm = fitgeotrans(alzheimerPts,normalPts,"affine");

"""TASK

Create a spatial referencing object using the size of the image of a normal brain, and save the result to Rfixed.
"""

Rfixed = imref2d(size(normal))

"""TASK

Transform the image of a brain with Alzheimer's to align it with the image of a normal brain. Save the result to alzTransform, and display it overlaid with normal using imshowpair.
"""

alzTransform = imwarp(alzheimer,tForm,"OutputView",Rfixed);
imshowpair(normal,alzTransform)

"""You can try marking your own control points by uncommenting the line with cpselect and running the script. When you export the control points to the workspace, be sure to name them alzheimerPts and normalPts, then close the app.

3. Geometric Transformations

The eye scan of advanced AMD has been rotated 90
âˆ˜
 clockwise. You can use imrotate to rotate images.

* movTransf = imrotate(moving,angle);

The second input, angle, is measured in degrees counterclockwise.
"""

early = imread("earlyAMD.jpg");
advanced = imread("advancedAMD.jpg");
imshowpair(advanced,early,"montage")

"""TASK

Rotate the eye scan showing advanced AMD so it is oriented the same way as the earlier scan.

Save the result to advTransform. Display it side-by-side with the early AMD scan using imshowpair with the "montage" option.
"""

advTransform = imrotate(advanced,90);
imshowpair(advTransform,early,"montage")

"""The advanced AMD is slightly zoomed out compared to the early AMD image. You can use imresize to change the size of an image.

* movTransf = imresize(moving,scale);

The second input is the scaling factor, which is a positive number. A factor larger than 1 causes the image to increase in size, and a factor smaller than 1 causes it to decrease.

For example, to reduce an image's size by 25%, use a scaling factor of 0.75.
* movTransf = imresize(moving,0.75);

TASK

Resize advTransform so it is 10% larger. Save the result back to advTransform, and display it overlaid with early using imshowpair.
"""

advTransform = imresize(advTransform,1.1);
imshowpair(advTransform,early)

"""You can see in the overlay that the advanced AMD scan still needs to be translated. You can use imtranslate to translate an image.

movTransf = imtranslate(moving,translation);

The second input is a two element vector specifying the translations in the x and y directions.

For example, to shift an image six pixels in the x-direction and seven pixels in the y-direction, use [6 7].
movTransf = imtranslate(moving,[6 7]);

TASK

Translate the advanced AMD image 5 pixels in the x direction and 10 pixels in the y direction. Save the result back to advTransform, and display it overlaid with early.
"""

advTransform = imtranslate(advTransform,[5 10]);
imshowpair(advTransform,early)

"""3. Geometric transformation

You can use imregcorr to estimate the geometric transformation between images using phase correlation.

tForm = imregcorr(moving,fixed,type)

The third input is the type of transformation passed as a string. The default is "similarity"

"""

early = imread("earlyAMD.jpg");
advanced = imread("advancedAMD.jpg");
imshowpair(advanced,early,"montage")

"""TASK

Estimate a similarity transformation between the image of advanced AMD and early AMD. Use the image of advanced AMD as the moving image and early AMD as the fixed image. Save the resulting transformation to tFormAMD.
"""

tFormAMD = imregcorr(advanced,early)

"""The output of imregcorr is the geometric transformation. You can extract information about the geometric transformation with dot notation.

tForm.Dimensionality

The two properties are Dimensionality and the transformation matrix, T.

TASK

Extract the transformation matrix from tFormAMD, and save it to tMat.
"""

tMat = tFormAMD.T

"""You can use the imwarp function to apply a transformation to an image.

transformed = imwarp(moving,tForm);

TASK

Apply the transform tFormAMD to the image of advanced AMD, and save the result to advTransform.

Display the transformed image overlaid with early using imshowpair.
"""

advTransform = imwarp(advanced,tFormAMD);
imshowpair(advTransform,early)

"""By default, imregcorr finds the optimal geometric transformation of type "similarity", which is a combination of translation, rotation, and scaling. By passing a third input, you can also specify to use translation only ("translation") or translation and rotation ("rigid").

tFormAMD = imregcorr(advanced,"rigid")

Try registering the images using the other two types of transformations supported by imregcorr.

4. Edge Detection

You can locate the edges of well-defined objects in a grayscale image by calling the edge function without specifying a threshold.
* defaultEdges = edge(gs)
"""

circles = imread("circles.jpg");
imshow(circles)

"""TASK

Detect the edges in circles using edge with the default settings. Store the result in circEdge and display it using imshow.
"""

circEdge = edge(circles);
imshow(circEdge)

"""The edges of two circles were identified, but the boundary of the third faint circle was missed due to low contrast. You can lower the detection threshold to capture the boundary of the third circle.

It's useful to know the default threshold chosen by edge to inform the selection of a new threshold. You can extract the default threshold by adding a second output to edge.
* [defaultEdges,thresh] = edge(gs)

TASK

Find the edges in circles using edge. Store the first output in circEdge and add a second output, thresh, to store the default threshold.
"""

[circEdge, thresh] = edge(circles);

"""Now that you have the default threshold, you can lower it to detect the edges of the third circle.
adjustedEdges = edge(gs,threshold)

TASK

Find the edges in circles again, but this time set the threshold input of edge to half the default threshold, thresh. Store the result in adjEdge and display it.
"""

adjEdge = edge(circles, thresh/2);
imshow(adjEdge)

"""Did you notice that the edges of the third circle were found but are a bit broken up? Another way to tune the detection is to select a different edge detection algorithm.

* [adjustedEdges,thresh] = edge(gs,method)

TASK

Find the edges in circles using the "log" method. Store the two outputs in adjEdge and thresh. Then display adjEdge.
"""

[adjEdge,thresh] = edge(circles,"log");
imshow(adjEdge)

"""While the "log" method was able to find the edge of the faint circle, it also created some noise. You can reduce the noise by raising the threshold.

adjEdge = edge(circles,"log",newThresh)

Try recomputing the edges with a higher threshold than the default: thresh*2. Is the noise reduced?

Remember that you can execute your script by clicking the Run or Run Section button in the MATLAB Toolstrip.

When you're finished practicing, you may move on to the next section.

Now that you know how to use the edge function, you can apply it to locate roundworms.

TASK

Find the edges in worms using edge with default settings. Store the result in wormsEdge and the default threshold output in thresh. Then display wormsEdge.
"""

worms = imread("worms.jpg");
wormsBW = imread("wormsBW.jpg");
imshow(worms)

[wormsEdge,thresh] = edge(worms);
imshow(wormsEdge)

"""Looks like there's some background noise captured both inside and around the worms. Try setting a higher threshold to avoid capturing weaker edges.

TASK

Find the edges in worms with the input threshold set to twice the default threshold, thresh. Store the result in wormsEdge and display it.
"""

wormsEdge = edge(worms,2*thresh);
imshow(wormsEdge)

"""That eliminated the noise, but it looks like some worm edges were fractured in the process. In cases where setting the threshold alone isn't enough, it's worth trying a different edge finding algorithm.

* [BW,threshOut] = edge(I,method)

TASK

Find the edges in worms using the "Canny" method with the default thresholds. Store the edges in wormsEdge and the default output in thresh. Then display wormsEdge.
"""

[wormsEdge,thresh] = edge(worms,"Canny");
imshow(wormsEdge)

"""
With the default thresholds, the Canny method is a bit overzealous for these worms. You can specify a two-element threshold when using the Canny method to fine-tune which edges are found.

* [BW,threshOut] = edge(I,"Canny",[low high]);

You can increase the high threshold to reduce the number of strong edges found in the initial pass.

TASK

Find the edges in worms again with the "Canny" method, but this time set the threshold to the two-element vector: [thresh(1) 0.2]. Store the result in wormsEdge and display it."""

wormsEdge= edge(worms,"Canny",[thresh(1) 0.2]);
imshow(wormsEdge)

"""That worked but you might notice there's some "stringing" at the ends of a few worms. This occurred because the low threshold is too low, causing extraneous faint edges to be identified because of their connection to the stronger worm edges. You can increase the low threshold to avoid picking up these undesirable edges.

TASK

Find the edges in worms again using the "Canny" method, but this time set the threshold to the two-element vector: [0.06 0.2]. Store the result in wormsEdge and display it.
"""

wormsEdge= edge(worms,"Canny",[0.06 0.2]);
imshow(wormsEdge)

"""Another way to get crisp edges is to binarize and preprocess the image with morphological operations first, and then detect edges of the binarized objects.

The preprocessed binary worms image,wormsBW, has already been loaded at the top of the script. Try finding the edges in wormsBW using edge. Then display the result together with wormsBW.

There are many objects in the image of blueberries: leaves, ground cover, unripe blueberries, and ripe blueberries. If you use the edge function without any preprocessing, the result is a bit of a mess.

On the other hand, if you threshold and binarize the image first, you can obtain clean edges of just the ripe blueberries. We've loaded a cleaned binary mask into BW. You can find the edges of connected objects in the binary image using bwboundaries.

* boundaries = bwboundaries(BW)

The output is a cell array where each element contains the boundary of a connected component.

TASK

Use bwboundaries to find the boundaries in BW and store the result in B.
"""

#This code imports and displays an image of blueberries.
berries = imread("blueberries.jpg");
imshow(berries)
#This code detects edges using the default Sobel method.
gs = im2gray(berries);
defaultEdges = edge(gs);
imshow(defaultEdges)
#This code imports the pre-made binary mask, created using HSV thresholding and cleaned with morphological operations.
BW = imread("BW.png");
imshow(BW)
#Task 1
B = bwboundaries(BW)

"""We can be certain that bwboundaries found the edges of the connected objects in the binary mask, but are they the edges of ripe blueberries? You can find out by visualizing the boundaries on top of the original image.

* visboundaries(boundaries)

TASK

Display the original image berries using imshow(berries).
Use hold on to continue plotting on the same axes.
Use visboundaries to add the boundaries, B, to the plot.
Then use hold off to stop plotting on the same axes.
"""

imshow(berries)
hold on
visboundaries(B)
hold off

"""Did you notice that three of the blueberries had small holes that were detected by bwboundaries?

That happened because, by default, bwboundaries finds boundaries of connected regions of 1s (foreground) and 0s (background). Sometimes, foreground regions can have areas of background inside of them, forming holes. To remove the holes, add the "noholes" option.

* boundaries = bwboundaries(BW,"noholes").

TASK

Update your code in Task 1 to remove the holes from the boundary image B.
"""

B = bwboundaries(BW,"noholes")

"""5. Thresholding

You can extract individual color planes by indexing.

* bluePlane = im(:,:,3);

Or, you can extract all of them at once with imsplit.

* [red,green,blue] = imsplit(im);

You can display images side by side using the "montage" method of imshowpair

* imshowpair(I1,I2,"montage")

TASK

Extract the red and green color planes from sb. Save them to the variables r and g respectively, and display them side-by-side.

You will not use the blue plane in this practice, so you can call it whatever you like or skip it.
"""

[r,g] = imsplit(sb);
imshowpair(r,g,"montage")

"""The strawberries are red, so you will first try segmentation using the red color plane. By itself, the red color plane is a grayscale image.

One way to segment a grayscale image is with the imbinarize function.

* BW = imbinarize(gs);

The output BW is a binary image where foreground pixels have value 1 and background pixels have value 0.

TASK

Create a binary mask using imbinarize on the red color plane. Save the result in a variable named sbBW, and display it using imshow.
"""

sbBW = imbinarize(r);
imshow(sbBW)

"""The segmentation using imbinarize included too many pixels.  

You can try setting a global threshold manually with a relational operator.

TASK

Create a mask that identifies all of the pixels with red intensity greater than 150. Save the result in the variable redMask, and display it.
"""

redMask = r > 150;
imshow(redMask)

"""The corners have high intensities for all of the color planes since they are bright. So, they will be hard to exclude using the red color plane.

Since red and green are the dominant colors in this image, another way to identify the strawberries is to look for pixels without much green.

TASK

Create a mask that identifies all of the pixels with green intensity less than 50. Save the result in the variable greenMask, and display it.
"""

greenMask = g < 50;
imshow(greenMask)

"""TASK

Create a binary mask that is true wherever the red intensity is higher than 175 and the green intensity is less than 150. Save the mask to rgMask, and display it.
"""

rgMask = (r > 175) & (g < 150);
imshow(rgMask)

"""TASK

Create a binary mask that is true everywhere that r-g is greater than 50. Save the result to diffMask, and display it.
"""

diffMask = (r - g) > 50;
imshow(diffMask)

"""6. Histogram

Similar to the image roundworms, the intensities in roundworms2 are limited to a small portion of the available range.

TASK

Increase the contrast in roundworms2 using the imadjust function. Save the result to rw2Adj.

You can run the whole script to see the intensity histogram and image comparison below.
"""

#This code sets up the activity.
roundworms = imread("worms.jpg");
rwAdj = imadjust(roundworms);
imhist(rwAdj)

roundworms2 = imread("worms2.jpg");
imhist(roundworms2)

#Task 1

rw2Adj = imadjust(roundworms2);


#Display the intensity histogram and adjusted images
imhist(rw2Adj)
imshowpair(rwAdj,rw2Adj,"montage")

"""The histograms for rwAdj and rw2Adj have very different profiles, and the two adjusted images show different levels of contrast. Ideally, the two adjusted histograms would have similar intensity profiles.

To adjust an image I to match the intensity profile of a reference image Iref, use the imhistmatch function.

* Iadj = imhistmatch(I,Iref);

TASK

Adjust the contrast in roundworms2 to match the intensity profile in rwAdj. Again, save the result to rw2Adj.

You can run a script to see the new intensity histogram an image comparison below.
"""

#Task 2
rw2Adj = imhistmatch(roundworms2,rwAdj);

#Display the intensity histogram and adjusted images
imhist(rw2Adj)
imshowpair(rwAdj,rw2Adj,"montage")

"""7. Spatial filters

You can create a filter using the fspecial function.

* filt = fspecial("type",filterSize)

You can use a 2-element vector for filterSize to define a rectangular window. An "average" filter replaces each pixel with the average of the pixels in the window around it.

TASK

Create a 3-by-3 averaging filter, and save it to avg.
"""

filterSize = [3 3];
avg = fspecial("average",filterSize);

"""You can use imfilter to filter an image with a specified filter.

imFiltered = imfilter(im,filt);

TASK

Filter tumor with the 3-by-3 averaging filter you created in Task 1. Save the result to tumorAvg, and display the result.
"""

tumorAvg = imfilter(tumor,avg);
imshow(tumorAvg)

"""Notice that the edges of tumorAvg are dark, even in the upper left where the edges used to be white. This is because edge pixels don't have a full neighborhood around them. By default imfilter pads the boundary with zeros. This darkens the edges.

You can specify a different boundary padding method as a third input to imfilter. The  "symmetric" method reflects the array across the border.

TASK

Filter tumor with a 3-by-3 averaging filter. This time use the "symmetric" method to pad the boundary.   Save the result back to tumorAvg, and display the result.
"""

tumorAvg = imfilter(tumor,avg,"symmetric");
imshow(tumorAvg)

"""The goal of this preprocessing was to create a better segmentation of the tumor.

TASK

Binarize tumorAvg using imbinarize. Save the result to tumorAvgBW, and display it.
"""

tumorAvgBW = imbinarize(tumorAvg);
imshow(tumorAvgBW)

"""The new segmentation is cleaner, but at the cost of making the image slightly blurry. When you used an averaging filter to smooth the image, you removed both noise and some detail.

Using a different filter size will change the appearance of the filtered image and the quality of the segmentation.

TASK

Filter tumor with an 15-by-15 averaging filter and use the "symmetric" method to pad the boundary.   Save the result back to tumorAvg.

Then  binarize tumorAvg using imbinarize. Save the result back to tumorAvgBW.

Display tumorAvg and tumorAvgBW side-by-side.
"""

filterSize = [15 15];
avg = fspecial("average",filterSize);
tumorAvg = imfilter(tumor,avg,"symmetric");
tumorAvgBW = imbinarize(tumorAvg);
imshowpair(tumorAvg,tumorAvgBW,"montage")

"""A larger filter makes the image more blurry, but that might not matter depending on your analysis. For this segmentation, the larger filter removes a lot of unwanted foreground from the mask.

Try different sizes of filter and boundary techniques to see the effect on the filtered image and segmentation.   The options for boundary techniques are "symmetric", "replicate", "circular", or you can specify a constant scalar. (The default is constant scaling with zeros.)
"""